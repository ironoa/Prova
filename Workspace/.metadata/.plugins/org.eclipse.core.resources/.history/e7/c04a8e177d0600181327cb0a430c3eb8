/*
 ============================================================================
 Name        : Template_Z_C_IO.c
 Author      : Alessio
 Version     :
 Copyright   : Your copyright notice
 Description : Gestione file e stringhe
 ============================================================================
 */

//ovviamente non sono necessari tutti questi include, da potare poi quando piu esperto
#include <stdio.h> //fondamentale di sicuro
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>//gestione file, es O_WRONLY
#include <string.h> //metodi per le stringhe

#define MAX_STRING_LENGTH 256
#define FILENAME_MAX 20



/********* LETTURA A CARATTERE DA STDIN ************/
char readc(){
	char c;
	char ok[100]; //di supporto per il flush del buffer dello stdin

	puts("Inserisci carattere dal leggere:");
	c=getchar(); //in un inserimento da std in getchar non consuma il \n dal buffer di in
	//while (getchar() != '\n');//Consuma il resto della linea, tecnica 1
	fgets(ok,sizeof(ok),stdin); //Consuma il resto della linea, tecnica 2

	return c;
}
/***************************************************************/


/*
 * Lettura a carattere di una linea da stdin.
 * Non lo posso chiamare filtro perchè non consuma tutto fino a EOF
 */
void readln_car(){
	char c;

	puts("Inserisci una linea:");
	do {
		c=getchar();

		//gestione del contenuto letto
		printf("%c ", c);//debug
	}
	while(c!= '\n');
	//il buffer di in ne esce pulito

}



/*
 * lettura da stdin di una riga
 */
char* readln(){
	char stringa[MAX_STRING_LENGTH];
	printf("Inserisci una linea: \n");
	//gets(stringa);//DEPRECATO MEGLIO fgets, inoltre non conserva il FINE LINEA
	/*
	 * gets puo essere utilizzato anche per fare flush del buffer di stdin dopo una lettura
	 * a singolo carattere con getchar
	 */
	fgets(stringa,sizeof(stringa),stdin); //fgets conserva eventuali fine linea
	/*
	 * se non voglio il fine linea letto da fgets
	 * strtok(riga, "\n"); //rimuovo il fine linea letto da fgets
	 */
	return stringa;
}


/************FILTRO a LINEA,LETTURA DA STDIN**************************/
void filterLine(){
	char stringa[FILENAME_MAX+1];

	printf("Inserisci un nome: \n");
	while( fgets(stringa,sizeof(stringa),stdin) != EOF ){
		strtok(stringa, "\n"); //rimuovo il fine linea letto da fgets

		//elaboro

		printf("Inserisci un nome: \n");
	}
}
/*************************************************************/

/************** FILTRO A CARATTERE DA STDIN L**************************/
void filterCar(){
	char err[MAX_STRING_LENGTH];
	char c;

	while( (c=getchar()) != EOF ) /* Fino ad EOF*/{

		//elaboro
	}
}
/**************************************************************/

/*
 * concatenazione di stringhe lette da stdin
 */
void readln_concat(){
	char riga [MAX_STRING_LENGTH];//alla fine concatenata
	char buf[MAX_STRING_LENGTH];//risultato parziale

	fgets(riga,sizeof(riga),stdin); //stringa ben formata = c'è il fine stringa
	strtok(riga, "\n"); //rimuovo il fine linea letto da fgets

	sprintf(buf,"%s",riga);	//formatted string, copio il risultato parziale

	strcat(riga, "parole a caso"); //la nuova stringa ricopre a partire dal fine stringa, riga continua ad essere stringa ben formata
}




/*********lettura RIGA DA STDIN e successiva scrittura su file*********/
void readln_writeFile(){
	char riga [MAX_STRING_LENGTH];

	fgets(riga,sizeof(riga),stdin); //stringa ben formata = c'è il fine stringa
	strtok(riga, "\n"); //rimuovo il fine linea letto da fgets

	//apertura file
	int fd = open("filename.txt", O_WRONLY);
	if (fd < 0){
		perror("P0: Impossibile creare/aprire il file");
		exit(EXIT_FAILURE);
	}
	//scrittura su file
	int bytes_to_write = strlen(riga);//strlen è una size of a runtime cucita sulla effettiva lunghezza della stringa
	int written = write(fd, riga, bytes_to_write);
	if (written < 0){
		perror("P0: errore nella scrittura sul file");
		close(fd);
		exit(EXIT_FAILURE);
	}
	//chiusura file
	close(fd);

}
/*****************************************************************/





/**************LETTURA FORMATTATA INTERO**********/
void myScanf_Int(){
	int in;
	char ok[100];

	puts("Inserire un numero intero:");

	//lettura formatta con controllo
	/*
	 * scanf non consuma in automatico i new line, e nemmeno il buffer in generale se
	 * fa match con le occorrenze cercate.
	 */
	while(scanf("%d", &in)!=1){
		/*
		 * inserimento non corretto
		 * flush
		 * ci riprovo
		 */
		fgets(ok,sizeof(ok),stdin); //Consuma il resto della linea, tecnica 2
		printf("buffer liberato: %s\n", ok);//debug

		puts("Inserire un numero intero:");
	}
	fgets(ok,sizeof(ok),stdin); //Consuma il resto della linea, tecnica 2
	printf("buffer liberato: %s\n", ok);//debug

}
/*****************************************************************/



